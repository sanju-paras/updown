<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Up and Down the River Scorekeeper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Body and Font Styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #2d3748; /* Dark text */
        }
        /* Custom scrollbar for player list (for better UX on desktop) */
        .player-list-container::-webkit-scrollbar {
            width: 8px;
        }
        .player-list-container::-webkit-scrollbar-track {
            background: #e2e8f0; /* Light gray track */
            border-radius: 4px;
        }
        .player-list-container::-webkit-scrollbar-thumb {
            background: #a0aec0; /* Medium gray thumb */
            border-radius: 4px;
        }
        .player-list-container::-webkit-scrollbar-thumb:hover {
            background: #718096; /* Darker gray on hover */
        }
        /* Style for number inputs to hide default arrows (cross-browser compatibility) */
        input[type='number']::-webkit-inner-spin-button,
        input[type='number']::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type='number'] {
            -moz-appearance: textfield;
        }

        /* Custom class for highlighting accurate bids */
        .accurate-bid-row {
            background-color: #81c784 !important; /* A more noticeable green */
            font-weight: 700 !important; /* Bold text */
            color: #1b5e20 !important; /* Darker green text for contrast */
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="app" class="max-w-4xl mx-auto bg-white shadow-lg rounded-xl p-6 md:p-8">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-blue-800 mb-6">Up and Down the River Scorekeeper</h1>

        <!-- Player Setup Section -->
        <div class="mb-8 p-4 bg-blue-50 rounded-lg shadow-inner">
            <h2 class="text-xl font-semibold mb-3 text-blue-700">Players</h2>
            <div id="player-input-section" class="flex flex-col sm:flex-row gap-3 mb-4">
                <input type="text" id="new-player-name" placeholder="Enter player name" class="flex-grow p-3 border border-blue-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-300">
                <button id="add-player-btn" class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition duration-200 ease-in-out shadow-md">Add Player</button>
            </div>
            <div id="players-list" class="flex flex-wrap gap-2 mb-4">
                </div>
            <button id="start-game-btn" class="w-full bg-green-600 text-white p-3 rounded-lg hover:bg-green-700 transition duration-200 ease-in-out shadow-md text-lg font-semibold">Start Game</button>
        </div>

        <!-- Game Section (Hidden initially, shown after game starts) -->
        <div id="game-section" class="hidden relative"> <!-- Added relative for reset button positioning -->
            <!-- Reset Game Button - Top Right -->
            <div class="absolute top-0 right-0 p-4">
                <button id="reset-game-btn" class="bg-red-500 text-white p-2 rounded-lg hover:bg-red-600 transition duration-200 ease-in-out shadow-md text-sm font-semibold">Reset Game</button>
            </div>

            <div class="mb-6 text-center">
                <h2 class="text-2xl md:text-3xl font-bold text-gray-800 mb-2">Round <span id="current-round-number">1</span>: <span id="cards-dealt">7</span> Cards</h2>
                </div>

            <!-- Scoreboard Table -->
            <div class="overflow-x-auto mb-6 bg-white rounded-lg shadow">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Player</th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Bid</th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actual</th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">R<span id="current-round-score-col">1</span> Score</th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total Score</th>
                        </tr>
                    </thead>
                    <tbody id="scoreboard-body" class="bg-white divide-y divide-gray-200">
                        </tbody>
                </table>
            </div>

            <!-- Navigation Buttons - Bottom -->
            <div class="flex justify-center gap-4 mt-4">
                <button id="prev-round-btn" class="bg-gray-300 text-gray-800 p-3 px-6 rounded-lg hover:bg-gray-400 transition duration-200 ease-in-out shadow-md disabled:opacity-50 disabled:cursor-not-allowed">Previous Round</button>
                <button id="next-round-btn" class="bg-indigo-600 text-white p-3 px-6 rounded-lg hover:bg-indigo-700 transition duration-200 ease-in-out shadow-md disabled:opacity-50 disabled:cursor-not-allowed">Next Round</button>
            </div>
        </div>

        <!-- Custom Message Box (for alerts and confirmations, replaces browser's alert/confirm) -->
        <div id="message-box" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm md:max-w-md lg:max-w-lg w-full text-center">
                <p id="message-content" class="text-lg font-semibold mb-4"></p>
                <div id="message-box-buttons" class="flex justify-center gap-3">
                    </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global Game State Variables ---
        let players = []; // Array of player names (strings)
        let gameRounds = []; // Stores game data for each round for each player.
        let currentRound = 0; // The current round index (0-indexed)

        // Constants for card dealing limits and session storage key
        const ABSOLUTE_MAX_ODD_CARDS_CAP = 13;
        const ABSOLUTE_MAX_EVEN_CARDS_CAP = 14;
        const PLAYERS_STORAGE_KEY = 'upDownRiverPlayers'; // Key for session storage

        let roundCardCounts = []; // Array storing the number of cards for each round in sequence

        // --- DOM Element References ---
        const newPlayerNameInput = document.getElementById('new-player-name');
        const addPlayerBtn = document.getElementById('add-player-btn');
        const playersListDiv = document.getElementById('players-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const gameSection = document.getElementById('game-section');
        const playerSetupSection = document.querySelector('.p-4.bg-blue-50.rounded-lg.shadow-inner');
        const currentRoundNumberSpan = document.getElementById('current-round-number');
        const cardsDealtSpan = document.getElementById('cards-dealt');
        const scoreboardBody = document.getElementById('scoreboard-body');
        const nextRoundBtn = document.getElementById('next-round-btn');
        const prevRoundBtn = document.getElementById('prev-round-btn');
        const resetGameBtn = document.getElementById('reset-game-btn');
        const currentRoundScoreCol = document.getElementById('current-round-score-col');

        const messageBox = document.getElementById('message-box');
        const messageContent = document.getElementById('message-content');
        const messageBoxButtons = document.getElementById('message-box-buttons');

        /**
         * Saves the current list of players to session storage.
         */
        function savePlayersToStorage() {
            try {
                sessionStorage.setItem(PLAYERS_STORAGE_KEY, JSON.stringify(players));
            } catch (e) {
                console.error("Error saving players to session storage:", e);
                // Optionally, show a non-intrusive message to the user about storage issues
            }
        }

        /**
         * Loads players from session storage.
         * @returns {Array<string>} An array of player names.
         */
        function loadPlayersFromStorage() {
            try {
                const storedPlayers = sessionStorage.getItem(PLAYERS_STORAGE_KEY);
                return storedPlayers ? JSON.parse(storedPlayers) : [];
            } catch (e) {
                console.error("Error loading players from session storage:", e);
                return []; // Return empty array on error
            }
        }

        /**
         * Displays a custom message box with dynamic buttons and content.
         * This function replaces standard browser alert/confirm dialogs.
         * @param {string} content - The content (can be plain text or HTML string) to display.
         * @param {function} [onConfirm=null] - Optional callback function to execute if the 'confirm' action is taken.
         * If provided, the box will show 'Confirm' and 'Cancel' buttons.
         * @param {string} [confirmText='OK'] - Text for the confirm button.
         * @param {string} [cancelText='Cancel'] - Text for the cancel button (only if onConfirm is provided).
         */
        function showMessageBox(content, onConfirm = null, confirmText = 'OK', cancelText = 'Cancel') {
            messageContent.innerHTML = content;
            messageBoxButtons.innerHTML = ''; // Clear any existing buttons from previous calls

            if (onConfirm) {
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = confirmText;
                confirmBtn.className = 'bg-blue-600 text-white p-2 px-4 rounded-lg hover:bg-blue-700 transition duration-200 ease-in-out shadow-md';
                confirmBtn.onclick = () => {
                    onConfirm();
                    hideMessageBox();
                };
                messageBoxButtons.appendChild(confirmBtn);

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = cancelText;
                cancelBtn.className = 'bg-gray-300 text-gray-800 p-2 px-4 rounded-lg hover:bg-gray-400 transition duration-200 ease-in-out shadow-md';
                cancelBtn.onclick = hideMessageBox;
                messageBoxButtons.appendChild(cancelBtn);
            } else {
                const okBtn = document.createElement('button');
                okBtn.textContent = 'OK';
                okBtn.className = 'bg-blue-600 text-white p-2 px-4 rounded-lg hover:bg-blue-700 transition duration-200 ease-in-out shadow-md';
                okBtn.onclick = hideMessageBox;
                messageBoxButtons.appendChild(okBtn);
            }
            messageBox.classList.remove('hidden');
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.classList.add('hidden');
        }

        /**
         * Dynamically calculates the highest odd number of cards for the ascending sequence.
         * Rule: (52 - 1) / number of players, rounded down to nearest whole odd number,
         * capped at ABSOLUTE_MAX_ODD_CARDS_CAP.
         * @returns {number} The calculated highest odd number of cards.
         */
        function getHighestOddCardCount() {
            if (players.length === 0) {
                return 1; // Default if no players
            }

            let calculatedVal = Math.floor(51 / players.length);

            // Adjust to nearest whole odd number
            if (calculatedVal % 2 === 0) {
                calculatedVal--;
            }

            // Ensure it's at least 1
            if (calculatedVal < 1) {
                calculatedVal = 1;
            }

            return Math.min(calculatedVal, ABSOLUTE_MAX_ODD_CARDS_CAP);
        }

        /**
         * Dynamically calculates the highest even number of cards for the descending sequence.
         * Rule: (52 - 1) / number of players, rounded down to nearest whole even number,
         * capped at ABSOLUTE_MAX_EVEN_CARDS_CAP.
         * @returns {number} The calculated highest even number of cards.
         */
        function getHighestEvenCardCount() {
            if (players.length === 0) {
                return 2; // Default if no players (smallest even)
            }

            let calculatedVal = Math.floor(51 / players.length);

            // Adjust to nearest whole even number
            if (calculatedVal % 2 !== 0) {
                calculatedVal--;
            }

            // Ensure it's at least 2
            if (calculatedVal < 2) {
                calculatedVal = 2;
            }

            return Math.min(calculatedVal, ABSOLUTE_MAX_EVEN_CARDS_CAP);
        }

        /**
         * Generates the sequence of cards dealt per round for 'Up and Down the River'.
         * The sequence is now: down in evens, three rounds of 1, then up in odds.
         * @returns {number[]} An array containing the number of cards for each round.
         */
        function generateRoundCardCounts() {
            let counts = [];
            const highestEven = getHighestEvenCardCount();
            const highestOdd = getHighestOddCardCount();

            // Part 1: Descending even numbers (e.g., 14, 12, ..., 2)
            for (let i = highestEven; i >= 2; i -= 2) {
                counts.push(i);
            }

            // Part 2: Three rounds of 1 card
            for (let i = 0; i < 3; i++) {
                counts.push(1);
            }

            // Part 3: Ascending odd numbers (e.g., 1, 3, ..., 13)
            // Start from 1, to ensure it always starts with an odd number
            for (let i = 1; i <= highestOdd; i += 2) {
                counts.push(i);
            }
            return counts;
        }

        /**
         * Initializes or resets the game state variables and updates the UI to the player setup screen.
         * This function is for a full reset, clearing players and returning to setup.
         */
        function initializeGame() {
            players = loadPlayersFromStorage(); // Load players from session storage
            gameRounds = [];
            currentRound = 0;
            roundCardCounts = []; // Reset it to empty; will be generated in startGame()
            playersListDiv.innerHTML = ''; // Clear player list in setup
            newPlayerNameInput.value = ''; // Clear player name input
            gameSection.classList.add('hidden'); // Hide the game section
            playerSetupSection.classList.remove('hidden'); // Show the player setup section
            hideMessageBox(); // Hide message box on game reset
            renderPlayersList(); // Render the loaded players
        }

        /**
         * Resets the game state (rounds, scores) but keeps the existing players.
         * This is used when starting a new game immediately after a game ends, with the same players.
         */
        function resetGameKeepingPlayers() {
            gameRounds = []; // Clear old game data
            currentRound = 0; // Reset to first round

            // Recalculate round counts based on existing players (important as player count affects it)
            roundCardCounts = generateRoundCardCounts();

            // Re-initialize gameRounds structure for all rounds and existing players
            for (let i = 0; i < roundCardCounts.length; i++) {
                const roundData = {};
                players.forEach(player => {
                    roundData[player] = { bid: null, actual: null, score: null };
                });
                gameRounds.push(roundData);
            }
            renderScoreboard(); // Render the scoreboard for the new game
            hideMessageBox(); // Hide the final scores message box
        }

        /**
         * Adds a new player to the game if the name is not empty and not a duplicate.
         * Updates the player list display and saves to session storage.
         */
        function addPlayer() {
            const playerName = newPlayerNameInput.value.trim();
            if (playerName) {
                if (players.includes(playerName)) {
                    showMessageBox('Player with this name already exists!');
                    return;
                }
                players.push(playerName);
                newPlayerNameInput.value = ''; // Clear the input field
                renderPlayersList(); // Update the displayed list of players
                savePlayersToStorage(); // Save players after adding
            }
        }

        /**
         * Removes a player from the game.
         * Updates the player list display and saves to session storage.
         * @param {string} playerName - The name of the player to remove.
         */
        function removePlayer(playerName) {
            players = players.filter(p => p !== playerName); // Filter out the player to be removed
            renderPlayersList(); // Re-render the player list
            savePlayersToStorage(); // Save players after removing
        }

        /**
         * Renders the list of players added in the setup section with clickable remove buttons.
         */
        function renderPlayersList() {
            playersListDiv.innerHTML = ''; // Clear current list
            players.forEach(player => {
                const playerTag = document.createElement('div');
                playerTag.className = 'bg-blue-200 text-blue-800 px-4 py-2 rounded-full flex items-center gap-2 shadow-sm';
                playerTag.innerHTML = `
                    <span>${player}</span>
                    <button class="remove-player-tag text-blue-600 hover:text-blue-900 font-bold text-sm" data-player-name="${player}">&times;</button>
                `;
                playersListDiv.appendChild(playerTag);
            });

            // Attach event listeners to all 'remove player' buttons
            document.querySelectorAll('.remove-player-tag').forEach(button => {
                button.onclick = (e) => removePlayer(e.target.dataset.playerName);
            });
        }

        /**
         * Initiates the game:
         * - Checks if at least one player is added.
         * - Initializes the gameRounds data structure for all players and rounds.
         * - Hides the player setup section and displays the game section.
         * - Renders the scoreboard for the first round.
         */
        function startGame() {
            if (players.length < 1) {
                showMessageBox('Please add at least one player to start the game.');
                return;
            }

            gameRounds = []; // Reset gameRounds
            currentRound = 0; // Reset currentRound

            roundCardCounts = generateRoundCardCounts(); // Generate after players are set

            // Initialize the gameRounds structure for all rounds and players
            for (let i = 0; i < roundCardCounts.length; i++) {
                const roundData = {};
                players.forEach(player => {
                    // Each player's data for a round: bid, actual tricks won, and score
                    roundData[player] = { bid: null, actual: null, score: null };
                });
                gameRounds.push(roundData);
            }

            playerSetupSection.classList.add('hidden'); // Hide the player setup card
            gameSec